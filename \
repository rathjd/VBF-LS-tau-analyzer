//-----------------------------------------------------------------------------
// File:        analyzer.cc
// Description: Analyzer for ntuples created by TheNtupleMaker
// Created:     Fri Apr  5 13:23:28 2013 by mkntanalyzer.py
// Author:      Daniele Marconi
//-----------------------------------------------------------------------------
#include "analyzer.h"

#ifdef PROJECT_NAME
#include "PhysicsTools/TheNtupleMaker/interface/pdg.h"
#else
#include "pdg.h"
#endif

using namespace std;

// Structs useful for Analyzer

struct MyEventCollection {

        std::string label;
	vector <tau_s*> tau;
	vector <jet_s*> jet;
	vector <jet_s*> bjet;

	MyEventCollection(const std::string & label) {

	}

};

struct MyHistoCollection {

	std::string label;
	TH1F* h_njet;
	TH1F* h_jetpt;
	TH1F* h_jeteta;
	TH1F* h_jet1pt;
	TH1F* h_jet1eta;
	TH1F* h_jet2pt;
	TH1F* h_jet2eta;
	TH1F* h_dijetinvariantmass;
	TH1F* h_dijetdeltaeta;

	TH1F* h_tau1pt;
	TH1F* h_tau1eta;
	TH1F* h_tau2pt;
	TH1F* h_tau2eta;
	TH1F* h_ditauinvariantmass;
	TH1F* h_ditaucharge;
	TH1F* h_ditaucosdeltaphi;

	TH1F* h_met;

	TH1F* h_ht;

	MyHistoCollection(TFile * f, const std::string & inputlabel) {

		label = inputlabel;
		f->mkdir(inputlabel.c_str());
        	f->cd(inputlabel.c_str());

		h_njet = new TH1F("h_njet", "h_njet", 21, -0.5, 20.5);
		h_jetpt = new TH1F("h_jetpt", "h_jetpt", 50, 0., 500.);
		h_jeteta = new TH1F("h_jeteta", "h_jeteta", 30 , -5., 5.);
		h_jet1pt = new TH1F("h_jet1pt", "h_jet1pt", 50, 0., 500.);
		h_jet1eta = new TH1F("h_jet1eta", "h_jet1eta", 50 , -5., 5.);
		h_jet2pt = new TH1F("h_jet2pt", "h_jet2pt", 50, 0., 500.);
		h_jet2eta = new TH1F("h_jet2eta", "h_jet2eta", 50 , -5., 5.);
		h_dijetinvariantmass = new TH1F("h_dijetinvariantmass","h_dijetinvariantmass", 50, 0., 2750.);
		h_dijetdeltaeta = new TH1F ("h_dijetdeltaeta", "h_dijetdeltaeta", 20, 0., 10.);

		h_tau1pt = new TH1F("h_tau1pt", "h_tau1pt", 50, 0., 500.);
		h_tau1eta = new TH1F("h_tau1eta", "h_tau1eta", 30 , -3., 3.);
		h_tau2pt = new TH1F("h_tau2pt", "h_tau2pt", 50, 0., 500.);
		h_tau2eta = new TH1F("h_tau2eta", "h_tau2eta", 30 , -3., 3.);
		h_ditauinvariantmass = new TH1F("h_ditauinvariantmass", "h_ditauinvariantmass", 20, 0., 140.);
		h_ditaucharge = new TH1F("h_ditaucharge", "h_ditaucharge", 5, -4., 6.);
		h_ditaucosdeltaphi = new TH1F("h_ditaucosdeltaphi", "h_ditaucosdeltaphi", 50, -1.1, 1.1);

		h_met = new TH1F("h_met", "h_met", 6, 0., 120.);

		h_ht = new TH1F("h_ht", "h_ht", 50, 0., 1300.);
	}
};

//-----------------------------------------------------------------------------
int main(int argc, char** argv)
{
  // Get file list and histogram filename from command line

  commandLine cmdline;
  decodeCommandLine(argc, argv, cmdline);

  // Get names of ntuple files to be processed and open chain of ntuples

  vector<string> filenames = getFilenames(cmdline.filelist);
  itreestream stream(filenames, "Events");
  if ( !stream.good() ) error("unable to open ntuple file(s)");

  // Get number of events to be read

  //int nevents = 100;
  int nevents = stream.size();
  cout << "Number of events: " << nevents << endl;

  // Select variables to be read

  selectVariables(stream);


  // The root application is needed to make canvases visible during
  // program execution. If this is not needed, just comment out the following
  // line

  TApplication app("analyzer", &argc, argv);

  /*
	 Notes:
	
	 1. Use
	   ofile = outputFile(cmdline.outputfile, stream)
	
	 to skim events to output file in addition to writing out histograms.
	
	 2. Use
	   ofile.addEvent(event-weight)
	
	 to specify that the current event is to be added to the output file.
	 If omitted, the event-weight is defaulted to 1.
	
	 3. Use
	    ofile.count(cut-name, event-weight)
	
	 to keep track, in the count histogram, of the number of events
	 passing a given cut. If omitted, the event-weight is taken to be 1.
	 If you want the counts in the count histogram to appear in a given
	 order, specify the order, before entering the event loop, as in
	 the example below
	 
	    ofile.count("NoCuts", 0)
		ofile.count("GoodEvent", 0)
		ofile.count("Vertex", 0)
		ofile.count("MET", 0)
  */
  
  outputFile ofile(cmdline.outputfilename);
  ofile.count("NoCuts",0.);
  ofile.count("TriggerRequirement",0.);
  ofile.count("AtLeast1tau",0.);
  ofile.count("AtLeast2tau",0.);
  ofile.count("DiTauDeltaRCut",0.);
  ofile.count("NoBTag",0.);
  //ofile.count("METCut",0.); 
  ofile.count("DiTauInaviantMassCut",0.);
  ofile.count("DiTauSignCut",0.);
  //ofile.count("LeadJet",0.);
  //ofile.count("SecondJet",0.);
  //ofile.count("DiJetDeltaRCut",0.);
  //ofile.count("DiJetEtaSignCut",0.);
  //ofile.count("DiJetEtaCut",0.);
  //ofile.count("DiJetMassCut",0.);
  //ofile.count("invertedvbfcut",0.);

  //---------------------------------------------------------------------------
  // Declare histograms
  //---------------------------------------------------------------------------

  

  double weight = 1.;

  TH1F* h_njet = new TH1F("h_njet", "h_njet", 21, -0.5, 20.5);
  TH1F* h_jetpt = new TH1F("h_jetpt", "h_jetpt", 50, 0., 500.);
  TH1F* h_jeteta = new TH1F("h_jeteta", "h_jeteta", 30 , -5., 5.);
  TH1F* h_jet1pt = new TH1F("h_jet1pt", "h_jet1pt", 50, 0., 500.);
  TH1F* h_jet1eta = new TH1F("h_jet1eta", "h_jet1eta", 50 , -5., 5.);
  TH1F* h_jet2pt = new TH1F("h_jet2pt", "h_jet2pt", 50, 0., 500.);
  TH1F* h_jet2eta = new TH1F("h_jet2eta", "h_jet2eta", 50 , -5., 5.);
  TH1F* h_dijetinvariantmass = new TH1F("h_dijetinvariantmass","h_dijetinvariantmass", 50, 0., 2750.);
  TH1F* h_dijetdeltaeta = new TH1F ("h_dijetdeltaeta", "h_dijetdeltaeta", 20, 0., 10.);

  TH1F* h_tau1pt = new TH1F("h_tau1pt", "h_tau1pt", 50, 0., 500.);
  TH1F* h_tau1eta = new TH1F("h_tau1eta", "h_tau1eta", 30 , -3., 3.);
  TH1F* h_tau2pt = new TH1F("h_tau2pt", "h_tau2pt", 50, 0., 500.);
  TH1F* h_tau2eta = new TH1F("h_tau2eta", "h_tau2eta", 30 , -3., 3.);
  TH1F* h_ditauinvariantmass = new TH1F("h_ditauinvariantmass", "h_ditauinvariantmass", 20, 0., 140.);
  TH1F* h_ditaucharge = new TH1F("h_ditaucharge", "h_ditaucharge", 5, -4., 6.);
  TH1F* h_ditaucosdeltaphi = new TH1F("h_ditaucosdeltaphi", "h_ditaucosdeltaphi", 50, -1.1, 1.1);
  
  TH1F* h_met = new TH1F("h_met", "h_met", 6, 0., 120.);

  TH1F* h_ht = new TH1F("h_ht", "h_ht", 50, 0., 1300.);
  
  //Baseline Selection Plots

  TH1F* h_baseline_taupt = new TH1F("h_baseline_taupt", "h_baseline_taupt", 50, 0., 500.);
  TH1F* h_baseline_taueta = new TH1F("h_baseline_taueta", "h_baseline_taueta", 30, -3., 3.);
  TH1F* h_baseline_tau1pt = new TH1F("h_baseline_tau1pt", "h_baseline_tau1pt", 50, 0., 500.);
  TH1F* h_baseline_tau1eta = new TH1F("h_baseline_tau1eta", "h_baseline_tau1eta", 30 , -3., 3.);
  TH1F* h_baseline_tau2pt = new TH1F("h_baseline_tau2pt", "h_baseline_tau2pt", 50, 0., 500.);
  TH1F* h_baseline_tau2eta = new TH1F("h_baseline_tau2eta", "h_baseline_tau2eta", 30 , -3., 3.);
  TH1F* h_baseline_ditaudeltar = new TH1F("h_baseline_ditaudeltar", "h_baseline_ditaudeltar", 30 , 0., 10.);
  TH2F* h2_baseline_ditaudeltar_vs_tau1pt = new TH2F("h2_baseline_ditaudeltar_vs_tau1pt","h2_baseline_ditaudeltar_vs_tau1pt",50, 0., 500.,30, 0., 10.);
  TH2F* h2_baseline_ditaudeltar_vs_tau2pt = new TH2F("h2_baseline_ditaudeltar_vs_tau2pt","h2_baseline_ditaudeltar_vs_tau2pt",50, 0., 500.,30, 0., 10.);

  TH1F* h_baseline_njet = new TH1F("h_baseline_njet", "h_baseline_njet", 21, -0.5, 20.5);
  TH1F* h_baseline_nbjet = new TH1F("h_baseline_nbjet", "h_baseline_nbjet", 11, -0.5, 10.5);
  TH2F* h2_baseline_nbjet_vs_njet = new TH2F("h2_baseline_nbjet_vs_njet", "h2_baseline_nbjet_vs_njet",21, -0.5, 20.5, 11, -0.5, 10.5);
  TH1F* h_baseline_jetpt = new TH1F("h_baseline_jetpt", "h_baseline_jetpt", 50, 0., 500.);
  TH1F* h_baseline_jeteta = new TH1F("h_baseline_jeteta", "h_baseline_jeteta", 30 , -5., 5.);
  TH1F* h_baseline_jet1pt = new TH1F("h_baseline_jet1pt", "h_baseline_jet1pt", 50, 0., 500.);
  TH1F* h_baseline_jet1eta = new TH1F("h_baseline_jet1eta", "h_baseline_jet1eta", 50 , -5., 5.);
  TH1F* h_baseline_jet2pt = new TH1F("h_baseline_jet2pt", "h_baseline_jet2pt", 50, 0., 500.);
  TH1F* h_baseline_jet2eta = new TH1F("h_baseline_jet2eta", "h_baseline_jet2eta", 50 , -5., 5.);
  TH1F* h_baseline_dijetetasign = new TH1F("h_baseline_dijetetasign","h_baseline_dijetetasign",5, -2.5, 2.5);
  TH1F* h_baseline_dijetdeltar = new TH1F("h_baseline_dijetdeltar","h_baseline_dijetdeltar", 30 , 0., 10.);
  TH1F* h_baseline_dijetinvariantmass = new TH1F("h_baseline_dijetinvariantmass","h_baseline_dijetinvariantmass", 50, 0., 2750.);
  TH2F* h2_baseline_dijetinvariantmass_vs_jet1pt = new TH2F("h2_baseline_dijetinvariantmass_vs_jet1pt","h2_baseline_dijetinvariantmass_vs_jet1pt",50, 0., 500., 50, 0., 2750.);
  TH2F* h2_baseline_dijetinvariantmass_vs_jet2pt = new TH2F("h2_baseline_dijetinvariantmass_vs_jet2pt","h2_baseline_dijetinvariantmass_vs_jet2pt",50, 0., 500., 50, 0., 2750.);
  TH1F* h_baseline_dijetdeltaeta = new TH1F ("h_baseline_dijetdeltaeta", "h_baseline_dijetdeltaeta", 20, 0., 10.);

  //---------------------------------------------------------------------------
  // Histogram Collection Init
  //---------------------------------------------------------------------------

	MyHistoCollection test1 (ofile.file_, "test1");
	MyHistoCollection test2 (ofile.file_, "test2");
	MyHistoCollection test3 (ofile.file_, "test3");



  //---------------------------------------------------------------------------
  // Loop over events
  //---------------------------------------------------------------------------

  for(int entry=0; entry < nevents; ++entry)
	{
	  // Read event into memory
	  stream.read(entry);

	  // Uncomment the following line if you wish to copy variables into
	  // structs. See the header file analyzer.h to find out what structs
	  // are available. Each struct contains the field "selected", which
	  // can be set as needed. Call saveSelectedObjects() before a call to
	  // addEvent if you wish to save only the selected objects.
	  
	   fillObjects();
           
	  //if(entry%1000==0)
	  //cout << "--processing entry " << entry << " of " << nevents << endl;
	  // ----------------------
	  // -- object selection --
	  // ----------------------

          // vertex selection
	  bool goodVertex = true;

          if(!(         vertex.size() > 0                                 )) goodVertex = false;
	  if(goodVertex){
	    if( goodVertex ) vertex[0].selected = true;
	  }

          //trigger selection
          bool triggerRequirement = false;
   
          if (
                (triggerresultshelper_value_HLT_DoubleMediumIsoPFTau35_Trk1_eta2p1_Prong1_v3 == 1) ||
                (triggerresultshelper_value_HLT_DoubleMediumIsoPFTau35_Trk1_eta2p1_Prong1_v4 == 1) ||
                (triggerresultshelper_value_HLT_DoubleMediumIsoPFTau35_Trk5_eta2p1_Prong1_v2 == 1) ||
                (triggerresultshelper_value_HLT_DoubleMediumIsoPFTau35_Trk5_eta2p1_Prong1_v3 == 1) ||
                (triggerresultshelper_value_HLT_DoubleMediumIsoPFTau35_Trk5_eta2p1_Prong1_v4 == 1) ||
                (triggerresultshelper_value_HLT_DoubleMediumIsoPFTau35_Trk5_eta2p1_Prong1_v6 == 1)

             ) triggerRequirement = true;

	  // electron selection
	  for(unsigned int e = 0;e<electron.size();++e){
	    electron[e].selected = true;
	  }

	  // muon selection
	  for(unsigned int m =0;m<muon.size();++m){
	    muon[m].selected = false;
	    if(!(       fabs(muon[m].eta) < 2.4                                        )) continue;
	    if(!(       muon[m].pt > 20                                                )) continue;
	    if(!(       muon[m].isGlobalMuon                                           )) continue;
	    if(!(       muon[m].isTrackerMuon                                          )) continue;
	    if(!(       muon[m].isPFMuon                                               )) continue;
	    if(!(       muon[m].numberOfMatchedStations > 1                            )) continue;
	    if(!((       fabs(muon[m].muonBestTrack_dxy) < 0.2           ))  &&
                 (       fabs(muon[m]. muonBestTrack_dz) < 0.5                         )) continue;
	    if(!(       muon[m].globalTrack_normalizedChi2 < 10.                       )) continue;
	    if(!(       muon[m].globalTrack_hitPattern_numberOfValidMuonHits > 0       )) continue;
	    if(!(       muon[m].innerTrack_hitPattern_numberOfValidPixelHits > 0       )) continue;
	    if(!(       muon[m].innerTrack_hitPattern_pixelLayersWithMeasurement > 5   )) continue;
	    if(!(       muon[m].innerTrack_normalizedChi2 < 1.8                        )) continue;
	    if(!(       fabs(muon[m].innerTrack_dxy) < 3.                              )) continue;
	    if(!(       fabs(muon[m].innerTrack_dz) < 30.                              )) continue;
	    muon[m].selected = true;
	  }

          // tau selection
          for(unsigned int t =0;t<tau.size();++t){
            tau[t].selected = false;
            if(!(          fabs(tau[t].eta) <= 2.1                                     )) continue;
            if(!(          tau[t].pt >= 45.                                            )) continue;
            if(!(          tau[t].leadPFChargedHadrCand_pt >= 5.0                      )) continue;
            if(!(          tau[t].tauID_byTightCombinedIsolationDeltaBetaCorr3Hits > 0.5     )) continue;
            if(!(          tau[t].tauID_againstElectronTightMVA3 > 0.5                )) continue;
            if(!(          tau[t].tauID_againstMuonTight2 > 0.5                        )) continue;
            if(!(          (tau[t].tauID_decayModeFinding > 0.5) && (tau[t].signalPFChargedHadrCands_size == 1)                         )) continue;
            tau[t].selected = true;
          }

          // jet selection
	  // ? id ?
	  for(unsigned int j = 0;j<jet.size();++j){
	    jet[j].selected = false;
	    if(!(      jet[j].pt >= 50.                                                                      )) continue;
	    if(!(      fabs(jet[j].eta) <= 5.0                                                               )) continue;
	    if(!(      (jet[j].neutralHadronEnergy + jet[j].HFHadronEnergy) / jet[j].energy < 0.99           )) continue;
	    if(!(      jet[j].neutralEmEnergyFraction < 0.99                                                 )) continue;
	    if(!(      jet[j].numberOfDaughters > 1                                                          )) continue;
	    if(fabs(jet[j].eta) < 2.4) {
               if(!(      jet[j].chargedHadronEnergyFraction > 0                                             )) continue;
               if(!(      jet[j].chargedEmEnergyFraction < 0.99                                              )) continue;
               if(!(      jet[j].chargedHadronMultiplicity > 0                                               )) continue;
            }
            double mindeltaRtaujet = 99999.;  
            for(unsigned int t =0;t<tau.size();++t){
                   if (!(       tau[t].selected    )) continue;
                   double temp_mindeltaRtaujet = deltaR(jet[j].eta, jet[j].phi, tau[t].eta, tau[t].phi); 
                   if (temp_mindeltaRtaujet < mindeltaRtaujet) mindeltaRtaujet = temp_mindeltaRtaujet;
            }
            if(!(       mindeltaRtaujet >= 0.3                                                                  )) continue;
	    jet[j].selected = true;
	  }


          // btag selection
          for(unsigned int j = 0;j<jet.size();++j){
	    jet[j].btagselected = false;
	    if(!(      jet[j].pt >= 30.                                                                      )) continue;  // Original value 20
	    if(!(      fabs(jet[j].eta) <= 2.4                                                               )) continue;
	    if(!(      jet[j].bDiscriminator_combinedSecondaryVertexBJetTags > 0.244                         )) continue;
            double mindeltaRtaujet = 99999.;  
            for(unsigned int t =0;t<tau.size();++t){
                   if (!(       tau[t].selected    )) continue;
                   double temp_mindeltaRtaujet = deltaR(jet[j].eta, jet[j].phi, tau[t].eta, tau[t].phi); 
                   if (temp_mindeltaRtaujet < mindeltaRtaujet) mindeltaRtaujet = temp_mindeltaRtaujet;
            }
            if(!(       (mindeltaRtaujet >= 0.3) &&  (mindeltaRtaujet < 99999.)                              )) continue;
	    jet[j].btagselected = true;
          }

          
	  // ------------------------
	  // -- baseline selection --
	  // -----------------------

          while (true){

          	//At Least 2 taus cut
          	int ntau = 0;
          	for(unsigned int t =0;t<tau.size();++t){
             		if (tau[t].selected) ntau++;
          	}
          	if(!(                      ntau >= 2                                                   )) break;

                //Filling plots
          	unsigned int temp_tau1index = 99999;
          	unsigned int temp_tau2index = 99999;
          	double temp_tau1_pt = -99999.;
          	double temp_tau2_pt = -99999.;


           	for(unsigned int t =0;t<tau.size();++t){
             		if (!(       tau[t].selected    )) continue;
             		h_baseline_taupt -> Fill(tau[t].pt,weight);
			h_baseline_taueta -> Fill(tau[t].eta,weight);
          	}

         
          	for(unsigned int t =0;t<tau.size();++t){
			if (!(tau[t].selected)) continue;
			if (temp_tau1_pt < tau[t].pt) {temp_tau1index = t; temp_tau1_pt = tau[t].pt;} 
		}

		if (temp_tau1index < 99999) {
			h_baseline_tau1pt->Fill(tau[temp_tau1index].pt, weight);
			h_baseline_tau1eta->Fill(tau[temp_tau1index].eta, weight);
		}
 
		for(unsigned int t =0;t<tau.size();++t){
			if (!(tau[t].selected)) continue;
			if ( (temp_tau2_pt < tau[t].pt) && ( temp_tau1_pt > tau[t].pt) ) {temp_tau2index = t; temp_tau2_pt = tau[t].pt;} 
		}

		if (temp_tau2index < 99999) {
			h_baseline_tau2pt->Fill(tau[temp_tau2index].pt, weight);
			h_baseline_tau2eta->Fill(tau[temp_tau2index].eta, weight);
		}

		if ( (temp_tau1index < 99999) && (temp_tau2index < 99999) ) {

			double tempDiTauDeltaR = deltaR(tau[temp_tau1index].eta, tau[temp_tau1index].phi, tau[temp_tau2index].eta, tau[temp_tau2index].phi);
			h_baseline_ditaudeltar -> Fill(tempDiTauDeltaR, weight);
        		h2_baseline_ditaudeltar_vs_tau1pt -> Fill(tau[temp_tau1index].pt, tempDiTauDeltaR, weight);
          		h2_baseline_ditaudeltar_vs_tau2pt -> Fill(tau[temp_tau2index].pt, tempDiTauDeltaR, weight);

		}

		double temp_njet = 0;
		double temp_nbjet = 0;

		for(unsigned int j = 0;j<jet.size();++j){
  			if (jet[j].selected) temp_njet++;
  			if (jet[j].btagselected) temp_nbjet++;
		}

		h_baseline_njet -> Fill(temp_njet,weight);
		h_baseline_nbjet -> Fill(temp_nbjet,weight);
		h2_baseline_nbjet_vs_njet -> Fill(temp_njet,temp_nbjet,weight);
		//At Least 2 Jets with Pt > 30 GeV and Eta < 5

		int ngoodjet = 0;

		for(unsigned int j = 0;j<jet.size();++j){
  			if (!(jet[j].selected)) continue;
  			if (   (jet[j].pt > 30.) && (jet[j].eta < 5.)   ) ngoodjet++;
		}
          	if(!(                      ngoodjet >= 2                                                   )) break;

		unsigned int temp_jet1index = 99999;
		unsigned int temp_jet2index = 99999;
		double temp_jet1_pt = -99999.;
		double temp_jet2_pt = -99999.;

		for(unsigned int j = 0;j<jet.size();++j){
			if (!(jet[j].selected)) continue;
			h_baseline_jetpt->Fill(jet[j].pt, weight);
			h_baseline_jeteta->Fill(jet[j].eta, weight);
  			if (temp_jet1_pt < jet[j].pt) {temp_jet1index = j; temp_jet1_pt = jet[j].pt;} 
		}


		if (temp_jet1index < 99999) {
			h_baseline_jet1pt->Fill(jet[temp_jet1index].pt, weight);
			h_baseline_jet1eta->Fill(jet[temp_jet1index].eta, weight);
		}

		for(unsigned int j = 0;j<jet.size();++j){
			if (!(jet[j].selected)) continue;
			if (j == temp_jet1index) continue;
			if ((temp_jet2_pt < jet[j].pt) && (temp_jet1_pt > jet[j].pt)) {temp_jet2index = j; temp_jet2_pt = jet[j].pt;} 
		}

		if (temp_jet2index < 99999) {
			h_baseline_jet2pt->Fill(jet[temp_jet2index].pt, weight);
			h_baseline_jet2eta->Fill(jet[temp_jet2index].eta, weight);
		}

		double invmassDiJet = 0.;

		for(unsigned int j1 = 0;j1<jet.size();++j1){

			if (!(       jet[j1].selected    )) continue;

			for (unsigned int j2 = 0;j2<jet.size();++j2){

				if (!(       jet[j2].selected    )) continue;
				if (j1 == j2) continue;

            			TLorentzVector jet1_4v;
            			TLorentzVector jet2_4v;
 
	        		jet1_4v.SetPtEtaPhiE(jet[j1].pt, jet[j1].eta, jet[j1].phi, jet[j1].energy);
	        		jet2_4v.SetPtEtaPhiE(jet[j2].pt, jet[j2].eta, jet[j2].phi, jet[j2].energy);

            			TLorentzVector dijet_4v = jet1_4v + jet2_4v;

				double temp_invmassDiJet =  dijet_4v.M(); 
				if (     invmassDiJet < temp_invmassDiJet   ) {invmassDiJet = temp_invmassDiJet; temp_jet1index = j1; temp_jet2index = j2;}

			}

		}

		if ( (temp_jet1index < 99999) && (temp_jet2index < 99999) ) {

			double dijetdeltaeta =  fabs (jet[temp_jet1index].eta - jet[temp_jet2index].eta);
                	double dijetdeltar = deltaR(jet[temp_jet1index].eta, jet[temp_jet1index].phi, jet[temp_jet2index].eta, jet[temp_jet2index].phi);
                	int dijetetasign = 1;
                	if (   (jet[temp_jet1index].eta * jet[temp_jet2index].eta) < 0  ) dijetetasign = -1;
			h_baseline_dijetinvariantmass ->Fill(invmassDiJet, weight);
			h_baseline_dijetdeltaeta ->Fill(dijetdeltaeta, weight);
			h_baseline_dijetetasign ->Fill(dijetetasign, weight);
			h_baseline_dijetdeltar ->Fill(dijetdeltar, weight);
                        h2_baseline_dijetinvariantmass_vs_jet1pt -> Fill(jet[temp_jet1index].pt,invmassDiJet,weight);
                        h2_baseline_dijetinvariantmass_vs_jet2pt -> Fill(jet[temp_jet2index].pt,invmassDiJet,weight);
		}

		break;

           }  //END OF WHILE  


	  // ---------------------
	  // -- event selection --
	  // ---------------------

          //Filling Ttree before selection
          //fillTree (tree);

          //NoCuts
          ofile.count("NoCuts");
          
          //Trigger Requirement
          if(!(                      triggerRequirement                                          )) continue;
          ofile.count("TriggerRequirement");

          //AtLeast1tau
          int ntau = 0;
          for(unsigned int t =0;t<tau.size();++t){
             if (tau[t].selected) ntau++;
          }
          if(!(                      ntau >= 1                                                   )) continue;
          ofile.count("AtLeast1tau");

          //AtLeast2tau
          if(!(                      ntau >= 2                                                   )) continue;
          ofile.count("AtLeast2tau");

          //DiTauEtaCut
          //loop over good taus
          double DiTauDeltaR = 99999.;
          for(unsigned int t1 = 0;t1<tau.size();++t1){
             if (!(       tau[t1].selected    )) continue;
             for (unsigned int t2 = 0;t2<tau.size();++t2){
                if (t1 == t2) continue;
                if (!(       tau[t2].selected    )) continue;
                double tempDiTauDeltaR = deltaR(tau[t1].eta, tau[t1].phi, tau[t2].eta, tau[t2].phi);
                if (     tempDiTauDeltaR < DiTauDeltaR      ) DiTauDeltaR =  tempDiTauDeltaR;
             }
          }


          if(!(           ( DiTauDeltaR > 0.3) && (DiTauDeltaR < 99999.)  /*Var control*/        )) continue;
          ofile.count("DiTauDeltaRCut");

          //NoBTag
          bool nobtag = true;
          for(unsigned int j = 0;j<jet.size();++j){
             if (jet[j].btagselected) nobtag = false;
          } 
          if(!(                      nobtag                                                     )) continue;
          ofile.count("NoBTag");

          //MET Cut
          bool metcut = false;
          if (met[0].pt < 75.) metcut = true;
          //if(!(                      metcut                                                     )) continue;
          //ofile.count("METCut");

 
          //DiTauInaviantMassCut
          bool ditauinvariantmasscut = false;
          unsigned int temp_tau1index = 99999;
          unsigned int temp_tau2index = 99999;
          double temp_tau1_pt = -99999.;
          double temp_tau2_pt = -99999.;
         
          for(unsigned int t =0;t<tau.size();++t){
               if (!(tau[t].selected)) continue;
               if (temp_tau1_pt < tau[t].pt) {temp_tau1index = t; temp_tau1_pt = tau[t].pt;} 
          }

          for(unsigned int t =0;t<tau.size();++t){
               if (!(tau[t].selected)) continue;
               if ( (temp_tau2_pt < tau[t].pt) && ( temp_tau1_pt > tau[t].pt) ) {temp_tau2index = t; temp_tau2_pt = tau[t].pt;} 
          }

         double invmassDiTau = 99999.;

         if ( (temp_tau1index < 99999) && (temp_tau2index < 99999) ) {

            TLorentzVector tau1_4v;
            TLorentzVector tau2_4v;
 
            tau1_4v.SetPtEtaPhiE(tau[temp_tau1index].pt, tau[temp_tau1index].eta, tau[temp_tau1index].phi, tau[temp_tau1index].energy);
            tau2_4v.SetPtEtaPhiE(tau[temp_tau2index].pt, tau[temp_tau2index].eta, tau[temp_tau2index].phi, tau[temp_tau2index].energy);

            TLorentzVector ditau_4v = tau1_4v + tau2_4v;

            invmassDiTau = ditau_4v.M();
         }

         if (  (invmassDiTau < 90.)  ) ditauinvariantmasscut = true;
         if(!(                      ditauinvariantmasscut                                       )) continue;
         ofile.count("DiTauInaviantMassCut");
 
         //DiTauSignCut
         bool ditausigncut = false;
         int chargeDiTau = tau[temp_tau1index].charge * tau[temp_tau2index].charge;
         if (  (chargeDiTau < 0.)  ) ditausigncut = true;
         if(!(                      ditausigncut                                                )) continue; //NOW REQUIRING OPPOSITE SIGN
         ofile.count("DiTauSignCut");
          


          //LeadJet
          double leadjetpt = 0.;
          double leadjeteta = 0.;
 
          for(unsigned int j = 0;j<jet.size();++j){
            if (!(jet[j].selected)) continue;
            if (leadjetpt < jet[j].pt) {leadjetpt = jet[j].pt; leadjeteta = jet[j].eta;}
          }
          //if(!(                      (leadjetpt >= 75.) && (fabs(leadjeteta) < 5.)              )) continue; //DEACTIVATED
          //if(!(                      (leadjetpt >= 30.) && (fabs(leadjeteta) < 5.)              )) continue; 
          //ofile.count("LeadJet");
     
          //SubLeadJet
          double subleadjetpt = 0.;
          double subleadjeteta = 0.;
          
          for(unsigned int j = 0;j<jet.size();++j){
            if (!(jet[j].selected)) continue;
            if ((subleadjetpt < jet[j].pt) && (leadjetpt > jet[j].pt)) {subleadjetpt = jet[j].pt; subleadjeteta = jet[j].eta;}
          }
          //if(!(                      (subleadjetpt >= 50.) && (fabs(subleadjeteta) < 5.)          )) continue; //DEACTIVATED
          //if(!(                      (subleadjetpt >= 30.) && (fabs(subleadjeteta) < 5.)          )) continue;
          //ofile.count("SecondJet");
     
          //DiJetCuts

          bool passedDiJetEtaSignCut = false;
          bool passedDiJetEtaCut = false;
          bool passedDiJetMassCut = false;
          bool passedDiJetDeltaRCut = false;

          unsigned int jet1index = 99999;
          unsigned int jet2index = 99999;

          double invmassDiJet = 0.;
          double dealtaRDiJet = 0.;

          for(unsigned int j1 = 0;j1<jet.size();++j1){
   
             if (!(       jet[j1].selected    )) continue;
            
             for (unsigned int j2 = 0;j2<jet.size();++j2){

                if (!(       jet[j2].selected    )) continue;
                if (j1 == j2) continue;
               
            	TLorentzVector jet1_4v;
            	TLorentzVector jet2_4v;
 
	        jet1_4v.SetPtEtaPhiE(jet[j1].pt, jet[j1].eta, jet[j1].phi, jet[j1].energy);
	        jet2_4v.SetPtEtaPhiE(jet[j2].pt, jet[j2].eta, jet[j2].phi, jet[j2].energy);

            	TLorentzVector dijet_4v = jet1_4v + jet2_4v;

                double temp_invmassDiJet = dijet_4v.M();
                if (     invmassDiJet < temp_invmassDiJet   ) {invmassDiJet = temp_invmassDiJet; jet1index = j1; jet2index = j2;}

             }
          
          }

          dealtaRDiJet = deltaR(jet[jet1index].eta, jet[jet1index].phi, jet[jet2index].eta, jet[jet2index].phi);
          if (     dealtaRDiJet >= 0.3   ) passedDiJetDeltaRCut = true;
          if (     invmassDiJet > 700.   ) passedDiJetMassCut = true;                                    
          if (     (jet[jet1index].eta * jet[jet2index].eta ) < 0.         ) passedDiJetEtaSignCut = true;
          if (      fabs ( jet[jet1index].eta - jet[jet2index].eta ) > 4.2   ) passedDiJetEtaCut = true;
          
          //if(!(                      passedDiJetDeltaRCut                                       )) continue;  //DEACTIVATED
          //ofile.count("DiJetDeltaRCut");

          //if(!(                      passedDiJetEtaSignCut                                      )) continue;  //DEACTIVATED
          //ofile.count("DiJetEtaSignCut");

          //if(!(                      passedDiJetEtaCut                                          )) continue;  //DEACTIVATED
          //ofile.count("DiJetEtaCut");

          //DEACTIVATED
          //if(!(                      passedDiJetMassCut                                         )) continue;  //DEACTIVATED
          //ofile.count("DiJetMassCut");


          //INVERTED VBF CUT
          //if((    (leadjetpt >= 75.) && (fabs(leadjeteta)< 5.) && (subleadjetpt >= 50.) && (fabs(subleadjeteta) < 5.) && (passedDiJetDeltaRCut) && (passedDiJetEtaSignCut) && (passedDiJetEtaCut) && (passedDiJetMassCut)   )) continue;
          //ofile.count("invertedvbfcut");

	  // ---------------------
	  // -- fill histograms --
	  // ---------------------	  

          //JET SEL

          double temp_njet = 0;
  
          unsigned int temp_jet1index = 99999;
          unsigned int temp_jet2index = 99999;
          double temp_jet1_pt = -99999.;
          double temp_jet2_pt = -99999.;

          for(unsigned int j = 0;j<jet.size();++j){
            if (!(jet[j].selected)) continue;
            temp_njet++;
            h_jetpt->Fill(jet[j].pt, weight);
            h_jeteta->Fill(jet[j].eta, weight);
            if (temp_jet1_pt < jet[j].pt) {temp_jet1index = j; temp_jet1_pt = jet[j].pt;} 
          }

          h_njet->Fill(temp_njet, weight);

          if (temp_jet1index < 99999) {
             h_jet1pt->Fill(jet[temp_jet1index].pt, weight);
             h_jet1eta->Fill(jet[temp_jet1index].eta, weight);
          }

         for(unsigned int j = 0;j<jet.size();++j){
            if (!(jet[j].selected)) continue;
            if (j == temp_jet1index) continue;
            if ((temp_jet2_pt < jet[j].pt) && (temp_jet1_pt > jet[j].pt)) {temp_jet2index = j; temp_jet2_pt = jet[j].pt;} 
         }

         if (temp_jet2index < 99999) {
            h_jet2pt->Fill(jet[temp_jet2index].pt, weight);
            h_jet2eta->Fill(jet[temp_jet2index].eta, weight);
         }

         if ( (temp_jet1index < 99999) && (temp_jet2index < 99999) ) {
       
            double deltaeta =  fabs (jet[temp_jet1index].eta - jet[temp_jet2index].eta);
            h_dijetinvariantmass ->Fill(invmassDiJet, weight);
            h_dijetdeltaeta ->Fill(deltaeta, weight);

         }

         //TAUS

          if (temp_tau1index < 99999) {
             h_tau1pt->Fill(tau[temp_tau1index].pt, weight);
             h_tau1eta->Fill(tau[temp_tau1index].eta, weight);
          }

          if (temp_tau2index < 99999) {
             h_tau2pt->Fill(tau[temp_tau2index].pt, weight);
             h_tau2eta->Fill(tau[temp_tau2index].eta, weight);
          }

         if ( (temp_tau1index < 99999) && (temp_tau2index < 99999) ) {

            chargeDiTau = tau[temp_tau1index].charge * tau[temp_tau2index].charge;

            double cosdeltaphiDiTau = cos(deltaPhi(tau[temp_tau1index].phi, tau[temp_tau2index].phi));
            h_ditauinvariantmass ->Fill(invmassDiTau, weight);
            h_ditaucharge ->Fill(chargeDiTau, weight);
            h_ditaucosdeltaphi ->Fill(cosdeltaphiDiTau, weight);

         }

        // MET

        h_met -> Fill(met[0].pt, weight);

       // HT NEEDS TO BE DEFINED AND IMPLEMENTED!!!!!!!!!!
        //1F* h_ht = new TH1F("h_ht", "h_ht", 50, 0., 1300.);
  

	}

  stream.close();
  ofile.close();
  return 0;
}

